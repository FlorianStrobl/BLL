// datatypes: i32, f32

// keywords: func, let, group, use (for different files), f32, i32, Infinity, NaN, type, match

// symbols:
// +, - (unary and binary), *, /, **, ***, %
// &, |, ^, ~, <<, >>
// ==, !=, <=, >=, <, >
// =, :, ->, => () (grouping and argument list), ;, ,, . (for accessing public values from namespaces), {} (for namespaces), [] (for type templating)

// global functions: IO.out[T](x: T): T, IO.in[T](defaultOnError: T): T
// IO.timestamp(): i32, IO.random(): f32
// IO.exit[T](value: T): never

// TODO how to do IO in LC?, Monads

// example code
//let a: i32 = IO.in[i32](0); // gets an i32 from the console
let b: i32 = Math.sq(a); // a ** 2, TODO compiler/interpreter must deduce that Math.sq[i32] is called and not Math.sq[f32]
// let c: i32 = IO.out(b); // prints b and assigneds b to c

/*
group IO {
  let out[T] = func (value: T): T => __INTERNAL_CODE_OUTPUT;
  let in[T] = func (defaultOnError: T): T => __INTERNAL_CODE_INPUT;

  let random = func (): f32 => __INTERNAL_CODE_RANDOM;
  let timestamp = func (): i32 => __INTERNAL_CODE_TIMESTAMP;

  let exit[T] = func (value: T): undetermined /* : never */=> __INTERNAL_CODE_EXIT;
}
*/

group LambdaCalculus {
  let id[T] = func (x: T): T => x;

  let application[T, U, G] = func (a: U -> T, b: U): G => a(b);
  let selfApp[T, U] = func (x: T): U => x(x); // TODO types

  let if[T] = func (bool: i32, a: T, b: T): T => bool(a, b);
  let true[T] = func (a: T): T -> T => func (b: T): T => a;
  let false[T] = func (a: T): T -> T => func (b:  T): T => b;

  // type: https://rosettacode.org/wiki/Y_combinator
  let const[T, U] = func (a: T): U -> T => func (any: U): T => a;

  let yCombinator[T, U, G] = func (f: T): TODO =>
    (func (x: U): TODO => f(x(x)))
    (func (x: G): TODO => f(x(x)));
  // or:
  // let yCombinator = func (f) => self(func (x) => f(x(x)));
}

group Bin {
  let and = func (a: i32, b: i32): i32 => a & b;
  let or = func (a: i32, b: i32): i32 => a | b;
  let xor = func (a: i32, b: i32): i32 => a ^ b;
  let not = func (a: i32): i32 => ~a;

  let lshift = func (a: i32, b: i32): i32 => a << b;
  let rshift = func (a: i32, b: i32): i32 => a >> b;
}

group Tuple {
  type A[T, T2] = T -> T -> T; // TODO

  //let tuple[T, T2, U: A[T, T2]] = func (a: T): (T)->(U)->T|T2 -> (b: T2): (U)->T|T2 -> (f: U): T|T2 -> f(a)(b); // TODO

  let first = LambdaCalculus.True;
  let second = LambdaCalculus.False;
}

// TODO add math functions

group Math {
  // constants
  let NAN = func (): f32 => NaN;
  let INFINITY = func (): f32 => Infinity;
  let NEGATIVE_INFINITY = func (): f32 => -Infinity;
  let PI = func (): f32 => 3.141592653589793;
  let E = func (): f32 => 2.718281828459045;
  let SQRT2 = func (): f32 => 1.4142135623730951;

  let MAX_SAFE_INTEGER = func (): f32 => 16777215;

  // float functions
  let isInteger = func (x: f32): i32 => x > MAX_SAFE_INTEGER() | trunc(x) == x; // TODO, precision
  let decimals = func (x: f32): f32 => x - trunc(x); // TODO, precision

  // basic arithmetic
  let add[T] = func (x: T, y: T): T => x + y;
  let sub[T] = func (x: T, y: T): T => x - y;
  let mult[T] = func (x: T, y: T): T => x * y;
  let div[T] = func (x: T, y: T): T => x / y; // truncs for i32
  let mod = func (a: i32, b: i32): i32 => a % b;

  // more complex arithmetic
  let exp[T] = func (b: T, e: T): T => b ** e;
  let log[T] = func (x: T, b: T): T => x *** b; // truncs for i32

  // trigonometric functions
  let sin = func (x: f32): f32 => x; // TODO
  let cos = func (x: f32): f32 => sin(x + Math.PI / 2.0);
  let tan = func (x: f32): f32 => sin(x) / cos(x);

  let arcsin = func (x: f32): f32 => x; // TODO
  let arccos = func (x: f32): f32 => arcsin(-x) + Math.PI / 2.0;
  let arctan = func (x: f32): f32 => arcsin( x / (1.0 + x*x)**0.5 );

  let sinh = func (x: f32): f32 => (Math.E ** x - Math.E ** -x)/2.0;
  let cosh = func (x: f32): f32 => (Math.E ** x + Math.E ** -x)/2.0; // (1.0 + sinh(x) ** 2.0) ** 0.5;
  let tanh = func (x: f32): f32 => sinh(x) / cosh(x);

  let arcsinh = func (x: f32): f32 => Math.ln(x + (x*x + 1.0)**0.5);
  let arccosh = func (x: f32): f32 => Math.ln(x + (x*x - 1.0)**0.5);
  let arctanh = func (x: f32): f32 => 0.5 * Math.ln((1.0+x)/(1.0-x));

  // popular operations
  let sq[T] = func (x: T): T => x*x;
  let diff[T] = func (x: T, y: T): T => abs(x - y); // TODO, abs[i32] is not defined
  let neg = func (x: f32): f32 => - x;
  let inv = func (x: f32): f32 => 1 / x;
  let root = func (x: f32, r: f32): f32 => exp(x, 1/r);
  let sqrt = func (x: f32): f32 => exp(x, 0.5);
  let eexp = func (x: f32): f32 => exp(E, x);
  let hypot = func (x: f32, y: f32) => sqrt(sq(x) + sq(y));

  // comparisons
  let equal[T] = func (x: T, y: T): i32 => x == y;
  let notEqual[T] = func (x: T, y: T): i32 => x != y;
  let greaterThan[T] = func (x: T, y: T): i32 => x > y;
  let lessThan[T] = func (x: T, y: T): i32 => x < y;
  let greaterThanOrEqual[T] = func (x: T, y: T): i32 => x >= y;
  let lessThanOrEqual[T] = func (x: T, y: T): i32 => x <= y;

  // sign functions
  let abs = func (x: f32): f32 => (x >= 0)(x, -x);
  let sign = func (x: f32): i32 => (x == 0)(0, (x > 0)(1, -1)); // TODO, what about x==NaN, how to check even NaN!?

  // minimum and maximum functions
  let min[T] = func (x: T, y: T): T => (x < y)(x, y); // TODO, what about x or y being NaN
  let max[T] = func (x: T, y: T): T => -min(-x, -y); // TODO, NaN
  let clamp[T] = func (x: T, min: T, max: T): T => min(max(num, min), max);

  // rounding functions
  let trunc = func (x: f32): f32 => uToF(fToU(x)); // Toward 0, TODO NaN
  let floor = func (x: f32): f32 => (x >= 0)(trunc(x), isInteger(x)(x, trunc(x) - 1)); // Toward -Infinity
  let ceil = func (x: f32): f32 => isInteger(x)(x, floor(x) + 1); // Towards +Infinity
  let round = func (x: f32): f32 => floor(x + 0.5);

  // converting numbers from one type to another
  let floatToInt = func (x: f32): f32 => isInteger(x)(x, trunc(x));
  let uToF = func (x: f32): f32 => x;
}

group List {
  let createStack[T, _] = func(value: T): _ => Tuple.tuple(value)(NaN);

  let push[T, _] = func (value: T) => func (stack: _) => Tuple.tuple(value)(stack); // TODO
  let pop[T] = func (): T => stack(second);
  let top[T] = func (): T => stack(first);
}